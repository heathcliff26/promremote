
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>promremote: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/promremote/promremote/client.go (87.8%)</option>
				
				<option value="file1">github.com/heathcliff26/promremote/promremote/errors.go (46.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package promremote

import (
        "bytes"
        "fmt"
        "log/slog"
        "net/http"
        "regexp"
        "slices"
        "time"

        "github.com/golang/snappy"
        "github.com/prometheus/client_golang/prometheus"
        dto "github.com/prometheus/client_model/go"
        "github.com/prometheus/prometheus/model/timestamp"
        "github.com/prometheus/prometheus/prompb"
)

type Client struct {
        endpoint string
        instance string
        job      string
        username string
        password string
        registry *prometheus.Registry
}

type MetricData struct {
        Labels    map[string]string
        Timestamp time.Time
        Value     float64
}

func NewWriteClient(endpoint, instance, job string, reg *prometheus.Registry) (*Client, error) <span class="cov8" title="9">{
        if endpoint == "" </span><span class="cov1" title="1">{
                return nil, ErrMissingEndpoint{}
        }</span>
        <span class="cov8" title="8">if instance == "" </span><span class="cov1" title="1">{
                return nil, ErrMissingInstance{}
        }</span>
        <span class="cov8" title="7">if job == "" </span><span class="cov1" title="1">{
                return nil, ErrMissingJob{}
        }</span>
        <span class="cov7" title="6">if reg == nil </span><span class="cov1" title="1">{
                return nil, ErrMissingRegistry{}
        }</span>
        <span class="cov6" title="5">return &amp;Client{
                endpoint: endpoint,
                instance: instance,
                job:      job,
                registry: reg,
        }, nil</span>
}

func (c *Client) Endpoint() string <span class="cov8" title="7">{
        if c == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov7" title="6">return c.endpoint</span>
}

func (c *Client) Registry() *prometheus.Registry <span class="cov3" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return c.registry</span>
}

// Set credentials needed for basic auth, return error if not provided
func (c *Client) SetBasicAuth(username, password string) error <span class="cov6" title="4">{
        if username == "" || password == "" </span><span class="cov4" title="3">{
                return ErrMissingAuthCredentials{}
        }</span>
        <span class="cov1" title="1">c.username = username
        c.password = password
        return nil</span>
}

// Send TimeSeries to remote_write endpoint
func (c *Client) post(ts []prompb.TimeSeries) error <span class="cov6" title="5">{
        wr := prompb.WriteRequest{Timeseries: ts}
        data, err := wr.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="5">body := snappy.Encode(nil, data)

        req, err := http.NewRequest(http.MethodPost, c.Endpoint(), bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="5">req.Header.Add("Content-Encoding", "snappy")
        req.Header.Add("Content-Type", "application/x-protobuf")
        req.Header.Set("X-Prometheus-Remote-Read-Version", "0.1.0")
        if c.username != "" </span><span class="cov1" title="1">{
                req.SetBasicAuth(c.username, c.password)
        }</span>

        <span class="cov6" title="5">httpClient := http.Client{
                Timeout: time.Duration(10 * time.Second),
        }
        res, err := httpClient.Do(req)
        if err != nil </span><span class="cov4" title="3">{
                return err
        }</span>
        <span class="cov3" title="2">defer res.Body.Close()
        if res.StatusCode &lt; 200 || res.StatusCode &gt; 299 </span><span class="cov0" title="0">{
                return NewErrRemoteWriteFailed(res.StatusCode, req.Body)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Collect metrics from registry and convert them to TimeSeries
func (c *Client) collect() ([]prompb.TimeSeries, error) <span class="cov6" title="4">{
        ch := make(chan prometheus.Metric)
        go func() </span><span class="cov6" title="4">{
                c.registry.Collect(ch)
                close(ch)
        }</span>()

        <span class="cov6" title="4">var res []prompb.TimeSeries
        for metric := range ch </span><span class="cov6" title="4">{
                // Extract name of metric
                regex := regexp.MustCompile("fqName: \"([a-zA-Z_:][a-zA-Z0-9_:]*)\"")
                fqName := regex.FindStringSubmatch(metric.Desc().String())
                if len(fqName) &lt; 2 </span><span class="cov0" title="0">{
                        return nil, &amp;ErrInvalidMetricDesc{Desc: metric.Desc().String()}
                }</span>

                // Convert metric to readable format
                <span class="cov6" title="4">m := &amp;dto.Metric{}
                err := metric.Write(m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Extract labels
                <span class="cov6" title="4">labels := make([]prompb.Label, 0, len(m.Label)+3)
                labels = append(labels, prompb.Label{
                        Name:  "__name__",
                        Value: fqName[1],
                })
                labels = append(labels, prompb.Label{
                        Name:  "instance",
                        Value: c.instance,
                })
                labels = append(labels, prompb.Label{
                        Name:  "job",
                        Value: c.job,
                })
                dropLabels := []string{"__name__", "instance", "job"}
                for _, l := range m.Label </span><span class="cov10" title="12">{
                        if !slices.Contains(dropLabels, l.GetName()) </span><span class="cov10" title="12">{
                                labels = append(labels, prompb.Label{
                                        Name:  l.GetName(),
                                        Value: l.GetValue(),
                                })
                        }</span>
                }

                <span class="cov6" title="4">ts := prompb.TimeSeries{
                        Labels: labels,
                }

                // Extract value and timestamp
                var value float64
                if m.Counter != nil </span><span class="cov0" title="0">{
                        value = m.Counter.GetValue()
                }</span> else<span class="cov6" title="4"> if m.Gauge != nil </span><span class="cov6" title="4">{
                        value = m.Gauge.GetValue()
                }</span> else<span class="cov0" title="0"> if m.Untyped != nil </span><span class="cov0" title="0">{
                        value = m.Untyped.GetValue()
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("unknown metric type")
                }</span>
                <span class="cov6" title="4">ts.Samples = []prompb.Sample{
                        {
                                Value:     value,
                                Timestamp: timestamp.FromTime(time.Now()),
                        },
                }

                res = append(res, ts)</span>
        }
        <span class="cov6" title="4">return res, nil</span>
}

// Collect metrics and send them to remote server in interval.
// Does not block main thread execution
func (c *Client) Run(interval time.Duration, quit chan bool) <span class="cov1" title="1">{
        go func() </span><span class="cov1" title="1">{
                ticker := time.NewTicker(interval)
                defer ticker.Stop()
                slog.Debug("Starting remote_write client")
                for </span><span class="cov4" title="3">{
                        ts, err := c.collect()
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to collect metrics for remote_write", "err", err)
                        }</span>
                        <span class="cov4" title="3">err = c.post(ts)
                        if err != nil </span><span class="cov4" title="3">{
                                slog.Error("Failed to send metrics to remote endpoint", "err", err)
                        }</span> else<span class="cov0" title="0"> {
                                slog.Debug("Successfully sent metrics via remote_write")
                        }</span>
                        <span class="cov4" title="3">select </span>{
                        case &lt;-ticker.C:<span class="cov3" title="2"></span>

                        case &lt;-quit:<span class="cov1" title="1">
                                slog.Info("Received stop signal, shutting down remote_write client")
                                return</span>
                        }
                }
        }()
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package promremote

import (
        "fmt"
        "io"
)

type ErrMissingEndpoint struct{}

func (e ErrMissingEndpoint) Error() string <span class="cov0" title="0">{
        return "No endpoint for prometheus remote_write provided"
}</span>

type ErrMissingInstance struct{}

func (e ErrMissingInstance) Error() string <span class="cov0" title="0">{
        return "No instance name provided"
}</span>

type ErrMissingJob struct{}

func (e ErrMissingJob) Error() string <span class="cov0" title="0">{
        return "No job name provided"
}</span>

type ErrMissingRegistry struct{}

func (e ErrMissingRegistry) Error() string <span class="cov0" title="0">{
        return "No prometheus registry provided"
}</span>

type ErrRemoteWriteFailed struct {
        StatusCode int
        Body       string
}

func NewErrRemoteWriteFailed(status int, resBody io.ReadCloser) error <span class="cov10" title="2">{
        var body string
        b, err := io.ReadAll(resBody)
        if err != nil </span><span class="cov1" title="1">{
                body = err.Error()
        }</span> else<span class="cov1" title="1"> {
                body = string(b)
        }</span>
        <span class="cov10" title="2">return &amp;ErrRemoteWriteFailed{
                StatusCode: status,
                Body:       body,
        }</span>
}

func (e *ErrRemoteWriteFailed) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Prometheus remote_write returned with Status Code %d, expected 200. Response body: %s", e.StatusCode, e.Body)
}</span>

type ErrMissingAuthCredentials struct{}

func (e ErrMissingAuthCredentials) Error() string <span class="cov0" title="0">{
        return "Need both username and password, at least one of them is empty"
}</span>

type ErrInvalidMetricDesc struct {
        Desc string
}

func (e *ErrInvalidMetricDesc) Error() string <span class="cov0" title="0">{
        return "Received metric with invalid description: " + e.Desc
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
